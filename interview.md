# C++
1. C++面向对象的三个特性
    1. 封装
    2. 继承
    3. 多态
2. 面向对象的5个基本设计原则
    1. 单一职责原则
    2. 开放封闭原则
    3. 里氏替换原则
    4. 依赖倒置原则
    5. 接口隔离原则
3. C++多态的实现及原理
    1. 多态：静态多态（函数模版、函数重载，编译时确定）。动态多态（虚函数、继承关系，动态绑定，运行时确定）
    2. 动态多态实现条件：
        1. 虚函数
        2. 一个基类的指针或引用指向派生类的对象
    3. 实现方式：
        1. 在基类的函数前加上virtual关键字，在派生类中重写该函数，运行时将会根据对象的实际类型来调用相应的函数。如果对象类型是派生类，就调用派生类的函数；如果对象类型是基类，就调用基类的函数
    4. 实现原理：
        1. 每个对象中保存一个指向虚函数表的指针vptr，C++内部为每一个类维持一个虚函数表。
        2. 基类指针在调用成员函数时，就会去查找该对象的虚函数表，虚函数表第一个slot为对象type_info信息。之后的slots为虚函数的地址。
        3. 在运行时会调用虚函数表中的函数地址。
        4. 如果继承类中的成员函数覆盖了基类的函数，则虚函数表中的函数指针会被替换。
4. 模板中非类型参数与类型参数有什么区别
    1. 模板的默认实参与函数的默认实参一样，必须从右向左定义。
    2. 类型参数：内置类型、自定义类型、模版类型，使用class。
    3. 非类型参数：通过一个具体类型指定：如一个整型，指针或者左值引用。
5. 什么是智能指针？写一个智能指针类！
    1. 所谓智能指针就是智能/自动化的管理指针所指向的动态资源的释放。它是一个类，有类似指针的功能。
    2. C++智能指针：智能指针是利用引用计数，将一个计数器与类指向的对象相关联，引用计数跟踪该类有多少个对象的指针指向同一个对象。
    3. 主要的智能指针
        1. shared_ptr：共享式指针，是一个共享资源所有权的指针， 在shared_ptr类内部维护一个引用计数器，该引用计数器实际上是指向该资源的指针的个数。当该引用计数变为0时，系统就会彻底释放这个资源
        2. weak_ptr：为了解决shared_ptr循环引用而造成内存泄漏问题，weak_ptr和shared_ptr配合使用，weak_ptr创建不会引用shared_ptr的引用次数，weak_ptr类中lock()用来判断shared_ptr指向的资源是否存在，lock()返回shared_ptr指向对象的地址，如果这个返回值为空，则表示资源已经释放。
        3. unique_ptr：资源所有权独占的智能指针，用来取代auto_ptr
            1. unique_ptr不具有拷贝和赋值语义
            2. 通过reset()或者std::move()转移资源所有权
            3. 通过std::move()把指针放入容器
            4. 可以用于管理数组
    4. shared_ptr智能指针模版
        1. 智能指针将一个计数器与类指向的对象想关联，引用计数跟踪共有多少个指针共享同一对象
        2. 每次创建类的新对象时，初始化指针并将引用置为1
        3. 当对象作为另一个对象的副本而创建时，拷贝构造函数拷贝指针并增加与之对应的引用次数
        4. 当对一个对象进行赋值时，赋值操作符减少左操作数所指对象的引用次数，如果该次数减少为0，则删除对象。增加右操作数所指对象的引用次数。
        5. 调用析构函数时，令引用次数为0，释放对象
    ```C++
    class T;
    class RefPtr
    {
	    friend class SmartPtr;
	    RefPtr() : p(nullptr), cnt(0) {}
	    RefPtr(T* ptr) : p(ptr), cnt(1) {}
	    ~RefPtr() { delete p; }
	    int cnt;
	    T* p;
    };
    class SmartPtr
    {
    public:
	    SmartPtr(T* ptr) : rp(new RefPtr(ptr)) {}
	    SmartPtr(const SmartPtr& sp) : rp(sp.rp) { ++rp->cnt; }
	    SmartPtr& operator=(const SmartPtr& rhs)
	    {
		    ++rhs.rp->cnt;
		    if (--rp->cnt == 0)
			    delete rp;
		    rp = rhs.rp;
		    return *this;
	    }
	    ~SmartPtr()
	    {
		    if (--rp->cnt == 0)
		    	delete rp;
	    }
    private:
	    RefPtr *rp;
    };
    ```
6. C++与C的最大区别
    1. 面向对象：封装，继承，多态
    2. 引入引用
    3. const/inline/enum来代替宏定义
    4. namespace解决重名问题
    5. STL高效的数据结构和算法
7. C++虚函数
    1. 虚函数的作用
        1. 实现基类到派生类的多态
        2. 用于构造抽象基类
    2. 构造函数可以是虚函数吗
    3. 析构函数可以是虚函数吗
    4. 
8. 虚函数和纯虚函数的区别
    1. 类中声明并实现了虚函数，作用是为了该函数可以在子类中被覆盖，这样编译器可以使用后期绑定实现多态。纯虚函数只是一个接口，是函数声明，留在子类中实现。含有纯虚函数的类是抽象类，不能实例化对象
    2. 虚函数在子类中可以不重写，但是纯虚函数必须在子类中实现，
    3. 虚函数的类作为“实作继承”，也就是继承接口的同时也继承了父类的实现。纯虚函数的类为“介面继承”，关注接口的统一性，实现由子类完成
    4. 该纯虚函数的类为抽象类，只有被继承，并重写虚函数后，才能使用。
9. 野指针
    1. 野指针就是指向垃圾内存的指针
    2. 形成原因
        1. 指针没有被初始化
        2. 被free或delete后没有重置为nullptr
10. extern "C"的作用和解决的问题
    1. 作用：在C++源文件中的语句前加上extern “C”，表明它按照类C的编译和链接规则来编译和链接，而不是C++的
    2. 其次：被extern “C”限定的函数或变量是extern类型的
    2. 解决问题：主要解决在C++代码中调用C代码

# STL
1. STL空间配置器
    1. 如果数据大于128K使用一级配置器来分配内存，也就是malloc()，如果分配失败则使用类似于set_new_handle()函数来处理。
    2. 如果数据小于等于128K使用二级配置器内存池来分配内存，二级配置器维护一个自由链表，链表含有16个结点存放索引号，分别是8、16、32、...、128。每个索引号指向一小片内存区块，大小为索引号大小。实际分配的内存向上取8的倍数。每个链表的头结点由一个数组来维护，需要分配内存时从合适大小的链表中取一块，假设要分配一个10k内存，那么就找到最小的大于等于10k的块，也就是16k，从16k的空闲链表中取出一个用于分配，释放该块内存时，将内存节点归还链表。为了节省维持链表的开销，采用了一个union结构体，分配器使用union里的next指针来指向下一个结点，而用户则使用union的空指针表示该节点的地址。
2. vector的insert操作
    1. insert(position, n, value);
    2. size+n = capacity
        1. 如果插入的元素数量小于position后的元素数量。那么先将position后的元素逆序一一复制到vector的末尾。即vector[size+n-1]=vector[size-1] (capacity=size+n)。然后将添加的n个元素插入到position位置
        2. 如果插入的元素数量大于position后的元素数量。那么现将position后的元素逆序一一复制到vector的末尾。即vector[size+n-1]=vector[size-1] (capacity=size+n)。此时还有m个为填充的空间，将n个元素的末尾m个元素复制到这m个未填充的空间内。然后把n-m个元素顺序插入position位置
    3. size+n < capacity
        1. 同2，只是不全占有capacity的空余空间
    4. size+n > capacity
        1. 需要申请新的内存空间，将原vector元素复制到新的内存空间。然后按照3添加元素。
3. map和set是什么数据结构。
    1. 红黑树
4. unordered_set和unordered_map利用什么数据结构
    1. 哈希表
5. vector与deque有什么区别？
    1. deque是双端队列，头尾都可以插入，且时间复杂度为常数时间，vector只能在尾端插入元素
    2. vector是一块连续的内存，deque是不止一块内存。
    3. vector在内存重新分布时要复制全部的元素，而deque不用复制所有元素
    4. 存取元素时deque会比vector稍慢（因为deque跨内存访问元素）
    5. deque的迭代器在不同区块跳转时不是一般地指针
    6. deque与vector组织内存的方式不一样。在底层，deque按“页”（page）或“块”（chunk）来分配存储器，每页包含固定数目的元素。而vector只分配一块连续的内存
    7. deque自动收缩，vector不可以收缩。
# Data Struct
1. 红黑树
    1. 树根结点始终为黑色
    2. 叶子结点始终为黑色
    3. 其余结点若为红色，则其孩子结点必为黑色
    4. 从任意叶子结点到根节点所经过的黑色结点的数目相同。
2. 树结构在计算机中的应用
    1. AVL树：windows对进程地址空间的管理
    2. 红黑树：STL中map和set
    3. B/B+树：磁盘文件组织、数据索引和数据库索引
    4. Trie树（字典树）：统计和排序，字符串前缀匹配
# Algorithm
1. 从N个无序数中寻找Top-k个最小数(经典海量数据)
    1. 堆排序：构建K大小的最大堆。遍历N个数即求出这k个最小数，复杂度为O(nlgk)
    2. hash算法：将N个数映射到M个文件中，统计M个文件中最小的K个值，再利用归并排序将这M*K个数组合成一个文件。最后找出这个文件中最小的K个数。
# Operator System
1. 进程与线程的区别
    1. 进程是系统资源分配的基本单位
    2. 线程是系统独立调度的基本单位
    3. 进程可以并发执行，同一进程中的线程也可以并发执行
    4. 进程的创建和销毁都需要对系统资源进行分配和释放，消耗资源较大。线程的创建和销毁消耗资源较小。
    5. 进程切换时需要保存放去CPU环境和分配新进程的CPU环境，而线程切换只需要读写寄存器即可。
    6. 进程拥有独立的地址空间，线程共享进程的地址空间。
    7. 进程间通信需要依靠操作系统，而线程间通信只需要读写数据段。
2. 进程间调度算法
    1. 先来先服务调度算法(FCFS)
    2. 短作业优先调度算法
    3. 优先级调度算法
    4. 高响应比调度算法
    5. 时间片轮转法
    6. 多级反馈队列调度算法
3. 死锁产生的必要条件
    1. 互斥条件：一个资源被进程占用时，其他进程要是想占有该资源就需要等待。
    2. 不可剥夺条件：进程占有的资源只能由自己释放，不能别其他进程剥夺。
    3. 请求和保持条件：已经占有资源的进程申请新资源时，只有申请到新资源后原来占有的资源才能释放。
    4. 循环等待条件：在进程间存在循环申请链，当前进程所申请的资源正是下一次资源占有的。
4. 预防死锁
    1. 银行家算法。
5. 孤儿进程
    1. 一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程所收养，并由init进程对它们完成状态收集工作
6. 僵死进程
    1. 一个进程使用fork创建子进程，如果子进程退出，而父进程没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然在系统中，这种进程称为僵死进程
# Computer Network
1. TCP与UDP区别
    1. TCP面向连接，发送数据之前要建立连接；UDP是无连接的，即发送数据之前不需要建立连接。
    2. TCP提供可靠的服务，也就是说TCP连接传送的数据，无差错，不丢失，不重复，且按序到达；UDP尽最大努力交付，即不保证可靠交付。（TCP通过校验和，重传控制，序号标识，滑动窗口，确认应答实现可靠传输，如丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制）。
    3. UDP具有较好的实时性，工作效率比TCP高，适合于对高速传输和实时性有较高的通信或广播通信。
    4. TCP连接只能点到点，一对一；UDP支持一对一，一对多，多对一，多对多的交互通信。
    5. TCP对系统资源要求较多；UDP对系统资源要求较少。
    6. TCP字节流模式；UDP数据报模式。
    7. TCP的逻辑通信信道是全双工的可靠信道；UDP则是不可靠信道。
    8. TCP通信的最大吞吐量*由窗口大小和往返时间决定*
2. TCP建立连接的步骤（三次握手）
    1. 第一次握手：建立连接时，客户端发送SYN(X)包到服务器，并进入SYN_SENT状态，等待服务器确认。
    2. 第二次握手：服务器收到SYN(X)包，必须确认客户的SYN，以及发送一个自己的SYN包。即SYN(Y)+ACK(X+1)包，此时服务器进入SYN_RECV状态。
    3. 第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(Y+1)，此包发送完毕，客户端进入ESTABLISHED状态，服务器接收到此包后，服务器进入ESTABLISHED状态，完成三次握手。
3. TCP关闭连接的步骤（四次挥手）
    1. 当客户端的TCP数据发送完毕时，向服务器发送一个FIN包，进入FIN_WAIT_1状态。
    2. 服务器收到这个FIN包后，向客户端返回一个ACK，同时声明对方要求关闭连接。（发送ACK是为了防止这段时间内客户端重传FIN）,进入CLOSE_WAIT状态。此时客户端收到这个ACK后进入FIN_WAIT_2状态。
    3. 当服务器接收完毕客户端的数据后，要求彻底关闭连接，向客户端发送FIN包，进入LAST_ACK状态。
    4. 客户端收到FIN后给服务器端发送要给ACK，进入TIME_WAIT状态。
    5. 经过2MSL时间客户端关闭，服务器收到ACK后关闭。
4. 为社么采用三次握手。
    1. 如果采用两次握手，存在这种情况：在客户端发送SYN时由于网络延迟，以至于在连接释放后的某个时间段到达服务器，此时B收到失效的SYN，误以为A又发起了新的连接，于是向A发送SYN+ACK，此时新的连接就建立了。然而A不会对B的SYN+ACK做出回应，导致B一直等待A发送数据，造成资源浪费。
    2. 如果采用四次握手，过程繁琐，效率较低。
    3. 综上：三次握手是“为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。”
5. 为什么客户端在TIME_WAIT必须等待2MSL时间呢？
    1. 为了保证客户端发送的最后一个ACK能够到达服务器。这个ACK可能丢失，因而使处在LAST_ACK的服务器重发FIN，而客户端就能在2MSL时间内收到这个重传的FIN。接着客户端重传一次ACK。重新启动2MSL计时器。最后客户端和服务器都进入CLOSED状态。如果客户端在TIME_WAIT不等待一段时间，在发送完ACK后立即释放连接，那么就无法收到B重传的FIN，因此也不会再发送一次ACK。这样B就无法正常关闭。
    2. 防止“已失效的连接请求报文段”出现在链接中。客户端在发送完最后一个ACK后，经2MSL可以使本连接持续时间内产生的所有报文段在网络中消失，这样下一个新的连接中就不会出现失效的连接请求报文段。
6. 路由协议
    0. 静态路由和动态路由
    1. 动态路由分别有：内部网关协议(IGP)和外部网关协议(EGP)。
    2. 内部网关协议
        1. 距离向量路由算法（Bellman-Ford算法）：RIP
        2. 链路状态路由算法（Dijkstra算法）：OSPF、IS-IS
7. ISO七层协议
    1. 物理层
        1. 功能：以二进制数据形式在物理媒体上传输数据
        2. 协议族： 802.2 
    2. 数据链路层
        1. 功能： 物理寻址，同时将原始比特转换为逻辑传输线路
        2. 协议族： PPP, SLIP, MTU
    3. 网络层
        1. 功能： 点对点传输分组数据，控制子网的运行，如逻辑编址、分组传输、路由选择
        2. 协议族： IP, ICMP, ARP, RARP, OSPF, IGMP
    4. 传输层
        1. 功能： 接收上一层的数据，在必要的时候会把数据进行分割，并把数据交给网络层，且保证这些数据段有效达到对端。
        2. 协议族： TCP, UDP， SCTP
    5. 会话层
        1. 功能： 不同机器上的用户之间建立及管理会话
    6. 表示层
        1. 功能： 信息小语法语义以及它们的关联，如加密解密，转换翻译，压缩解压缩等。
    7. 应用层
        1. 功能： 各种应用程序协议
        2. 协议族： HTTP, FTP(TCP), SMTP(TCP), TELNET(TCP), DNS(TCP or UDP), SNMP(UDP)
8. TCP/IP参考模型
    1. 网络接口层
        1. ARP, RARP
    2. 网际层
        1. IP, ICMP, IGMP
    3. 传输层
        1. TCP, UDP
    4. 应用层
        1. FTP, HTTP, DNS, SMTP
9. 层级对应的设备
    1. 物理层：集线器，中继器
    2. 数据链路层：交换机或网桥
    3. 网络层：路由器
    4. 网络层以上：网关
10. HTTP协议
    1. HTTP协议：超文本传输协议，由请求和响应构成，永远都是客户端发起请求，服务器端响应请求，是一个标准的客户端服务器模型。
    2. HTTP协议是一个无状态协议，同一个客户端的这次请求和上次请求是没有对应关系的。
11. HTTP常用请求方式
    1. GET
        1. 从指定的资源请求数据。
    2. POST
        1. 向指定的资源提交要被处理的数据
12. 应用层协议及端口号
    1. HTTP:80
    2. SMTP:25
    3. FTP:21
    4. HTTPS:443
    5. DNS:53
13. HTTP报文
    1. HTTP报文面向文本，报文中每一个字段都是一些ASCII码串，各个字段长度不定，包含请求报文和响应报文
    2. 请求报文
        1. 请求行：请求方法“ ”URL“ ”协议版本“\n\r”
            1. 请求方法：GET POST HEAD PUT DELETE OPTIONS TRACE CONNECT
            2. GET：当从client要从server中读取文档时，使用GET方法，GET方法要求服务器将URL定位的资源放在响应报文的数据部分，回送给client。使用GET时，请求参数和对应的值附加在URL之后，利用一个问号代表URL的结尾和请求参数的开始，传递参数长度受限制
            3. POST：当client给服务器提供的信息较多时，使用POST方法，POST方法将请求参数封装在HTTP请求数据中，以KEY/VALUE形式出现，可以传递大量数据，可用来传递文件 Connect-Length必须给出
        2. 请求头部：头部字段名“：”值“\n\r”由key/value键值对组成，用：分隔。
        3. 空行："\n\r"请求头部之后的一个空行。通知服务器请求头结束
        4. 请求正文：请求数据不在GET中使用。在POST中使用。
    3. 响应报文
        1. 响应行：协议版本“ ”状态码“ ”描述“\n\r”
            1. 100：指示信息--表示请求已接收，继续处理
            2. 200：成功
            3. 3xx：重定向
                1. 301：永久重定向
                2. 302：临时重定向
                3. 304：NOT MODIFIED请求的资源没有改变，可以继续使用缓存
            4. 4xx：客户端错误
                1. 400：错误请求，如语法错误
                2. 403：禁止访问
                3. 404：没有发现文件、查询或URL
            5. 5xx服务器端错误
                1. 500：内部服务器错误
                2. 502：网关错误
                3. 503：服务器不可用
                4. 504：网关超时
        2. 响应头：描述服务器的基本信息，以及数据的描述，告诉客户端如何处理回送的数据
        3. 响应体：响应的消息体，返回纯数据或者代码段
14. HTTP1.0和HTTP1.1区别
    1. HTTP1.0对于每个连接都只能传送一个请求和响应，请求就会关闭，没有HOST字段
    2. HTTP1.1同一个连接可以传送多个请求和响应，多个请求可以重叠和同时进行，必须有HOST字段
15. HTTP与HTTPS的区别
    1. HTTPS = HTTP + SSL + 加密算法 + 证书验证
    2. HTTP(80) HTTPS(443)
    3. HTTPS需要申请证书。
    4. HTTP的消息是明文传输，HTTPS具有安全性的ssl加密传输协议
    5. HTTP简单无状态、HTTPS由HTTP+SSL+加密算法+证书验证进行数据加密和身份认证的网络协议。更加安全
16. HTTP CLIENT的两个超时
    1. 连接超时，指的是连接一个url的连接等待时间
    2. 读取数据超时：指的是连接上一个url，获取response的返回等待时间
17. 在浏览器中输入URL并回车后都发生了什么？
    1. 解析URL，抽取域名字段
    2. DNS解析，寻找该域名对应的ip地址
        1. 查询浏览器缓存
        2. 检查系统缓存(hosts文件)
        3. 检查路由器缓存
        4. 查询ISP DNS缓存
        5. 递归查询，从根域名服务器到顶级域名服务器再到次级域名服务器到主机名，查询对应的ip地址
    3. 浏览器（客户端）和网站（服务器）建立TCP连接（三次握手）
    4. 传输请求和传输数据
        1. 首次访问响应头中没有cookie信息，则提示服务器建立用户缓存数据，存储用户名、密码、用户设置项
        2. 首次访问之后，请求头中包含了cookie信息
    5. 浏览器渲染页面，显示html
    6. 显示嵌入在html中的对象（图片、css、js）
    7. 浏览器发送异步AJAX请求
    8. 渲染结束
18. cookie和session
    1. Cookie机制采用在客户端保存的方案，主要的作用在于解决HTTP协议无状态的问题
    2. Session采用在服务器端保持状态的方案，主要是在客户端和服务器端之间保持状态
    3. cookie保存在客户端，可以被修改容易伪造，且字段太多影响效率，最大4k。session保留在服务器端，相对来说安全，同时没有传输效率问题
    4. 访问服务器时，服务器创建一个session，此时先检查请求中是否含有sessionID，如果含有则找出该id的session，如果没有则创建session及id。该id唯一不重复无规律的字符串。该id会返回到客户端保存。这个id就是cookie
    5. 使用cookie传递sessionid，但是还可以通过url重写来传递sessionid
    
    综上：
    
    Session是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中

    Cookie是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现Session的一种方式。
19. cookie和session区别
    1. session 在服务器端，cookie 在客户端（浏览器）
    2. session 默认被存在在服务器的一个文件里（不是内存）
    3. session 的运行依赖 session id，而 session id 是存在 cookie 中的，也就是说，如果浏览器禁用了 cookie ，同时 session 也会失效（但是可以通过其它方式实现，比如在 url 中传递 session_id）
    4. session 可以放在 文件、数据库、或内存中都可以。
    5. 用户验证这种场合一般会用 session 因此，维持一个会话的核心就是客户端的唯一标识，即 session id

20. TCP报文头(20字节)
    1. 源端口(16) + 目的端口(16)
    2. 序列号(32)
    3. 确认应答(32)
    4. 头部长度(4) + 保留字段(6) + 控制位(6) + 窗口大小(16)
    5. 偏移量(16) + 校验和(16)
21. UDP报文头(8字节)
    1. 源端口(16) + 目的端口(16)
    2. 长度(16) + 校验和(16)
22. TCP如何保证数据发送
    > 主机每次发送数据时，TCP就会给每个数据包分配一个序列号并且在一个特定的时间内等待接收主机对序列号的确认应答，如果发送主机在特定时间内没有收到接收主机的确认应答，则发送主机就会重传该数据包，接收主机利用序列号对接收的数据进行确认，以便检测对方发送的数据是否丢失或者乱序，接收主机一旦收到已经顺序化的数据。就会 把这些数据按照正确的顺序重组成数据流传送到高层进行处理。
    1. 为了保证数据包的可靠传输，发送方必须把已发送的数据包保存到缓冲区。
    2. 并为每个已发送的数据包启动一个超时计时器。
    3. 如果在超时计时器超时之前收到了对方的确认应答（可能是对本包的确认应答，也可能是对后续包的确认应答），则释放该数据包占用的缓冲区
    4. 否则重传该数据包，直到接收对方的确认应答或重传次数超过最大次数为止。
    5. 接收方接收到数据包时先进行CRC验证，如果正确则把数据包交给上层协议，发送一个累计应答包，表明数据已经收到，如果此时接收端刚好有数据要发送给发送端，应答包可以在数据包中稍带过去。
23. close()与shutdown()
    1. close函数把描述符的引用计数减一，仅仅在该计数变为0的时候，才真正的关闭套接字，而使用shutdown函数可以不管引用计数就激发了TCP的正常连接终止序列；
    2. close函数终止读和写两个方向的数据传输。既然TCP连接是全双工的，有时候我们需要告知对端我们已经完成了数据发送，我们仅仅需要关闭数据发送的一个通道，但是我们还是可以接收到对端发送过来的数据，这种控制只有利用shutdown函数才能实现
24. TCP服务器端编程
    1. socket()--创建socket, setsockopt()--设置socket属性(可选)
    2. bind()--绑定ip端口到socket
    3. listen()--监听
    4. accept()--接收客户端连接
    5. send()、revc()、read()、write()--收发数据
    6. 关闭网络连接
    7. 关闭监听
25. TCP客户端编程
    1. socket(), setsockopt()
    2. bind()--绑定ip和端口
    3. 设置要连接的对方ip及端口
    4. connect()
    5. send(),revc(),read(),write()--收发数据
    6. 关闭网络连接
26. UDP服务器端
    1. socket()
    2. bind()
    3. recvfrom()
    4. 关闭连接
27. UDP客户端
    1. socket()
    2. bind()
    3. 设置对方ip及端口
    4. sendto()
    5. 关闭连接
28. GET POST区别
    1. GET在浏览器回退时是无害的，而POST会再次提交请求。
    2. GET产生的URL地址可以被Bookmark，而POST不可以。
    3. GET请求会被浏览器主动cache，而POST不会，除非手动设置。
    4. GET请求只能进行url编码，而POST支持多种编码方式。
    5. GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。
    6. GET请求在URL中传送的参数是有长度限制的，而POST么有。
    7. 对参数的数据类型，GET只接受ASCII字符，而POST没有限制。
    8. GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。
    9. GET参数通过URL传递，POST放在Request body中。
29. TCP重传机制
    1. 超时重传
        1. 在请求包发出去的时候，开启一个计时器，当计时器达到时间之后，没有收到ACK，则就进行重发请求的操作，一直重发直到达到重发上限次数或者收到ACK。
        2. RTO由采样RTT的平均值决定
    2. 快速重传
        1. 当接收方收到的数据包是不正常的序列号，那么接收方会重复把应该收到的那一条ACK重复发送，这个时候，如果发送方收到连续3条的同一个序列号的ACK，那么就会启动快速重传机制，把这个ACK对应的发送包重新发送一次。
30. TCP分段和IP分片
    1. MTU(最大传输单元)。在以太网中MTU=1500，如果IP数据报长度大于该MTU，就会分片，分片的数据报不一定按序到达，但是IP首部中的信息(标识、标志、片偏移)来让这些数据报片重组，IP数据报分片和重组都在网络层进行完成，分片主要是在路由器，重组主要是在目的主机。
    2. MSS(最大分段大小)。TCP报文段大于MSS就要分段。MSS会在TCP连接时双方商议好，即存在于SYN报文段中。MSS一般为MTU减去IP头部和TCP头部。TCP分段和重组在传输层完成。
    3. 由于MTU>=MSS，所以TCP报文段很少发生IP分片。
    4. UDP不会进行分段，当长度超过MTU时会进行分片。
    5. IP数据分片后，只有第一片带有UDP首部，其余分片只有IP头部
    6. TCP分段后，每个分段中都有TCP首部。
    7. 对于IP分片来说，即使只丢了一片数据也要重传整个数据报。重传由更高层协议负责。TCP分段中，如果某一段丢失后，TCP会重发整个TCP报文段。
31. Nagle算法
    1. Nagle算法主要是避免发送小的数据报，要求TCP连接上最多只能有一个未被确认的小分组，在该分组到达之前不能发送其它的小分组。相反，TCP收集这些小分组，并在确认到达来时以一个分组的形式发送出去。
    2. 对于MSS片段直接发送
    3. 如果有没有确认的data在缓冲区，先将待发送的数据放到buffer中直到该data被确认。
    4. Nagle算法会把连续的小分段组合发送，增加TCP传输效率，TCP连接上最多只能有一个未被确认的小分组。只有收到ACK后才发送第二个包
    5. 禁用Nagle后，每个小分组可以连续发送，不用等待ACK。
32. HTTPS的工作原理
    1. HTTPS在传输数据之前CS之间进行一次握手。在握手过程中确立对方加密传输数据的密码信息。
    2. TLS/SSL中有非对称加密、对称加密和HASH算法
    3. 握手过程
        1. 浏览器将自己支持的加密规则发送给网站。
        2. 网站从中选出一组加密算法和HASH算法，把自己的身份信息以证书(公钥)的形式发回给浏览器
        3. 浏览器获得证书后，验证证书合法性、使用约定的HASH计算握手信息。生成随机密钥并使用公钥进行加密，并将信息发给网站
        4. 网站收到信息后，解密取出密码后并加密发送握手信息
        5. 浏览器解密并计算握手信息的HASH，如果和网站发来的HASH相同，握手结束。
        6. 最后利用浏览器生成的随机密钥结合加密算法进行加密通信
33. TCP四种计时器
    1. 重传计时器：用于超时重传
    2. 坚持计时器：用于服务器端发来零窗口响应时开启，在计时期间如果没有收到窗口更新响应，就发送一个探测报文（不需要确认）来提醒对端重发。用于解决窗口更新丢失时，服务器端等待数据，客户端等待窗口更新而造成死锁
    3. 保活计时器：防止TCP连接出现长时间空闲，TCP连接服务器长时间（2h）未收到客户端数据时，会发送探测报文以确认客户端是否存在（75s，10次）。
    4. 时间等待计时器：2msl，连接终止时期，主动关闭端发送FIN后发送ACK开始，防止重复的FIN到达终点时丢弃
34. TCP重传机制  
ACK只能确认最大连续收到的分组
    1. 超时重传：发送方接收不到ack时会重新发送数据并超过了重传计时器时间。
    2. 快速重传：发送方连续收到三个最后可能丢失的ack。立即重传。解决了timeout问题
    3. 重传可能造成的问题：会发送丢失数据之后的数据包。
    4. 通过选择ack来解决问题3，根据sack就知道哪些数据到了哪些没到。
# Linux
1. awk: 适合格式化文本，对文本进行较复杂格式处理
    1. 逐行处理
    2. awk [option] 'pattern {action}' test.txt
    3. action: print\printf 
    4. pattern: BEGIN\END BEGIN: 在开始逐行处理文本之前，先执行BEGIN模式所指定的动作。END同理。
    5. [option]: -F :指定输入分隔符 -v : 设置变量的值
    6. $1: 第一列。$0: 整列。NF: 字段总数。 $NF: 每一行的最后一列。FS设定分隔符
    7. 可以将我们指定的字符串与每一列进行拼接，或者把指定的字符当作一个新列插入到原来的列中。
2. grep: 适合单纯的查找或匹配文本
3. sed: 适合编辑匹配到的文本
4. Linux启动过程
    1. 加载BIOS：BIOS中包含CPU相关信息、设备启动顺序信息、硬盘信息、内存信息、时钟信息、PnP特征等。由此可知计算机应该去读取哪个硬件设备
    2. 读取MBR：第0磁道第一个扇区。主引导目录512字节。存放预启动信息，分区表信息。系统将MBR复制到0X7c00地址所在的物理内存中。也就是boot loader
    3. 启动Boot Loader：通过这个在内核运行前执行的小程序，可以初始化硬件设备，建立内存空间映射图，将系统的软硬件带到一个合适的状态，以便为最终调用操作系统内核做好准备
    4. 加载内核：根据grub(Boot loader的一种)设定的内核映射所在的路径，系统读取内存映像，进行解压缩操作。解压后放入内存中，调用start_kernel()函数启动初始化函数以及各种设备，完成Linux内核环境的建立
    5. 用户层/sbin/init根据inittab文件设定运行等级：进行初始化工作。
        1. 7种运行等级
        2. 0：关机
        3. 1：单用户模式
        4. 2：无网络多用户模式
        5. 3：有网络多用户模式
        6. 4：保留，未使用
        7. 5：由网络支持有X-Window支持的多用户模式
        8. 6：重启
    6. init进程执行第一个用户层文件rc.sysinit设定PATH、网络配置、启动swap分区，设定/proc等
    7. 启动内核模块：根据/etc/modules.conf文件来装载内核模块
    8. 执行不同运行等级的脚本程序：根据运行级别不同，运行不同的脚本程序，完成初始化
    9. 执行/etc/rc.d/rc.local：Linux用户个性化设置启动的东西
    10. 执行/bin/login程序，进入登陆状态：输入username及password
5. crontab
    1. cron服务
        > service cron start // 启动服务

        > service cron stop  // 关闭服务

        > service cron restart // 重启服务
        
        > service cron reload  // 重新载入配置
         
    2. crontab
        > crontab -u // 设定某个用户的cron服务，
        
        > crontab -l // 列出某个用户cron服务详细内容
        
        > crontab -r // 删除某个用户的cron服务
        
        > crontab -e  // 编辑某个用户的cron服务

    3. crontab文件格式
        > {minute} {hour} {day of month} {month} {day of week} {full path to shell script}
        
        > minute : 0-59
        
        > hour : 0-23

        > day of month : 0-31

        > month : 1-12

        > day of week : 0-6

        > '*' : 代表所有的取值范围内的数字
        
        > '/' : 代表每的意思，"*/5"表示每5个单位

        > '-' : 表示某个数字到某个数字

        > ',' : 分开几个离散数字

    4. 举例
        1. */5 * * * * xxx.sh
        > 每5分钟执行
        2. 0 * * * * * xxx.sh
        > 每小时执行
        3. 0 0 * * * * xxx.sh
        > 每天执行
        4. 0 6 * * * * xxx.sh
        > 每天早上6点
        5. 0 */2 * * * xxx.sh
        > 每两个小时
        6. 0 23-7/2 * * * xxx.sh
        > 晚上11点到早上8点之间每2个小时
        7. 0 4 1 1 * * xxx.sh
        > 1月1日早上4点
    5. demo
    ```Shell
    #!/bin/bash
    var="http://www.google.com"
    echo $var
    exit 0
    ```
    save as test.sh
    > crobtab -e
    
    > */1 * * * * /home/mjc/CodeTest/test.sh >> /home/mjc/log.log

    

    int numComponents(ListNode* head, vector<int>& G) {
        unordered_set<int> setG (G.begin(), G.end());
        int res = 0;
        while (head != NULL) {
            if (setG.count(head->val) && (head->next == NULL || !setG.count(head->next->val))) res++;
            head = head->next;
        }
        return res;
    }
6. I/O多路复用
I/O多路复用就是通过一种机制，可以监听多个描述符，一旦某个描述符就绪，就能通知程序进行相应的读写操作
7. select
```C++
int select (int n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);
// fd_set：描述符集合
// readset、writeset、exceptset指定让操作系统测试读、写、异常条件的描述符
// timeout：告知内核等待所指定描述符中任何一个就绪可花多少时间
// 成功返回大于0，出错返回-1，超时返回0
```
每次调用select()都需要将三个描述符链表的内容全部从用户进程内存中复制到操作系统内核中，内核需要将所有fd_set遍历一遍，这个过程非常低效

返回结果中内核并没有声明哪些fd_set已经准备好了，所以如果返回值大于0，程序需要遍历所有的fd_set判断哪个IO已经准备好了

在 Linux 中 select 最多支持 1024 个 fd_set 同时轮询，其中 1024 由 Linux 内核的 FD_SETSIZE 决定。如果需要打破该限制可以修改 FD_SETSIZE，然后重新编译内核。

8. poll
```C++
int poll (struct pollfd *fds, unsigned int nfds, int timeout);
struct pollfd {
    int fd;       //文件描述符
    short events; //监视的请求事件
    short revents; //已发生的事件
};
```
和select功能基本相同，同样每次都需要把pollfd复制到内核，返回后同样需要轮询每一个pollfd是否哦已经IO准备好，poll取消1024各描述符数量上限，但是数量太大以后不能保证执行效率，因为复制大量内存到内核十分低效，所需要时间和描述符数量成正比，pollfd的重复利用上比fd_set好

多线程下，如果一个线程对某个描述符调用poll，但是另一个线程关闭了该描述符，会导致poll结果不确定

9. epoll
epoll仅仅适用于linux，它是select和poll增强版，更加灵活没有描述符限制，它将用户关系的描述符放到内核的事件表中。从而只需要在用户空间和内核空间拷贝一次

select/poll中，进程只有在调用一定的方法后，内核才对所有监视的描述符扫描，而epoll事先通过对epoll_ctl来注册描述符，一旦某个描述符就绪，内核会采用callback回调机制，迅速激活该描述符，当进程调用epoll_wait时便得到通知

epoll_ctl执行一次系统调用，用于向内核注册新的描述符或者改变某个文件描述符的状态，已注册的描述符在内核中会被维护在一棵红黑树上，通过回调函数内核将IO准备好的描述符放到一个链表中管理

epoll_wait取出在内核中通过链表维护的IO描述符，将它们从内核复制到程序

10. select/poll比较
    1. 它们提供了几乎相同的功能，但是在细节上不同
        1. select会修改fd_set参数，而poll不会
        2. select默认只能监听1024各描述符，如果监听更多需要修改FD_SETSIZE之后重新编译
        3. poll提供了更多的事件类型
    2. 速度
        1. 它们都采用轮询的方式找到IO完成的描述符，如果描述符很多就会很慢
        2. select只使用每个描述符的3位，poll通常使用64位，poll需要复制更多的内核空间
    3. 可移植性
        1. 几乎所有的系统支持select，但只有比较新的系统支持poll
